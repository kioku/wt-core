# Rule: no-println
# Discourages println!/dbg! in library code
#
# Bad:
#   println!("Processing user: {}", user.id);
#   dbg!(value);
#
# Good:
#   tracing::info!("Processing user: {}", user.id);
#   log::debug!("value = {:?}", value);

id: no-println
language: rust
severity: warning
message: "Avoid println!/dbg! in library code. Use a structured logger (tracing, log) instead."

ignores:
  - "**/main.rs"
  - "**/bin/**"
  - "**/build.rs"
  - "**/tests/**"
  - "**/test_*.rs"
  - "**/*_test.rs"
  - "**/*_tests.rs"
  - "**/examples/**"
  - "**/benches/**"
  # CLI binary with user-facing output
  - "**/src/main.rs"
  - "**/src/commands.rs"
  - "**/src/output.rs"

rule:
  any:
    - pattern: println!($$$)
    - pattern: print!($$$)
    - pattern: dbg!($$$)
    - pattern: eprintln!($$$)
    - pattern: eprint!($$$)
  not:
    inside:
      stopBy: end
      kind: mod_item
      follows:
        stopBy: end
        pattern: "#[cfg(test)]"

note: |
  println! and dbg! are for quick debugging, not production code.
  Issues:
  - No log levels (can't filter by severity)
  - No structured data (hard to parse/search)
  - Synchronous I/O (can block async runtimes)

  Use tracing or log crate for proper observability.
